/// <reference lib="webworker" />
import { cleanupOutdatedCaches, precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { NavigationRoute, registerRoute } from 'workbox-routing';
import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw';

declare let self: ServiceWorkerGlobalScope;

// --- 1. Workbox Standard Configuration ---
self.skipWaiting();
clientsClaim();
cleanupOutdatedCaches();

// Precache all assets generated by Vite
// @ts-expect-error - __WB_MANIFEST is injected by VitePWA
precacheAndRoute(self.__WB_MANIFEST);

// SPA Navigation Fallback
const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
    denylist: [
        /^\/api/,  // Exclude API calls
        /\.[a-z]+$/ // Exclude files with extensions
    ]
});
registerRoute(navigationRoute);


// --- 2. Firebase Configuration in SW ---
// We can access env vars via import.meta.env because Vite compiles this file!
const firebaseConfig = {
    apiKey: import.meta.env.NEXT_PUBLIC_FIREBASE_API_KEY,
    authDomain: import.meta.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
    projectId: import.meta.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
    storageBucket: import.meta.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
    messagingSenderId: import.meta.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
    appId: import.meta.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    measurementId: import.meta.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};

// Initialize Firebase only if config is valid (basic check)
if (firebaseConfig.apiKey) {
    const app = initializeApp(firebaseConfig);
    const messaging = getMessaging(app);

    // This handles messages received when app is in background or closed
    onBackgroundMessage(messaging, (payload) => {
        console.log('[firebase-messaging-sw.js] Received background message ', payload);

        // Customize notification here if needed
        const notificationTitle = payload.notification?.title || 'New Message';
        const notificationOptions = {
            body: payload.notification?.body,
            icon: '/icons/icon-192.png', // Fallback icon
            data: payload.data // Pass data for click handling
        };

        if (self.registration) {
            self.registration.showNotification(notificationTitle, notificationOptions);
        }
    });

    console.log("ðŸ”¥ [SW] Firebase Messaging Initialized");
} else {
    console.warn("âš ï¸ [SW] Firebase Config missing. Push notifications will not work.");
}

// --- 3. Notification Click Handling ---
self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    event.waitUntil(
        self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
            // If a window is already open, focus it
            for (const client of clientList) {
                if (client.url && 'focus' in client) {
                    return client.focus();
                }
            }
            // Otherwise open a new window
            if (self.clients.openWindow) {
                return self.clients.openWindow('/');
            }
        })
    );
});
